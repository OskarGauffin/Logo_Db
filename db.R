#   Introduction and general information
#
#   This program is written to perform data management on a file generated by 
#   E-prime in a study of dyslexia and learning patterns. The Eprime-file must be 
#   converted from xls-format to csv-format, with "," as decimal separator. 
#   Its output is a csv-file with one row/participant and a number of columns, 
#   depending on the users choice. That is, the program can generate result 
#   calculated by epoch, block, halfblock or all three categories at once. 
#   
#   After succesful execution it displays the number of participants and the number
#   of columns in the processed file, the name and location of the processed file 
#   and the runtime. For approximately 60 participants, the expected runtime is 
#   less than five minutes on a modern laptop. 
#
#   How do you run the program?
# 
#   Click the "db.R"-file and if required, select R-studio as the program
#   to open such files with. In the bottom left of the screen, after the ">"
#   enter "db()" without quotation marks. A prompt will ask you to specify
#    by what category you want the program to process the data, with four 
#   possible choices. If you fail to choose a supported choice, you will be asked
#   again, until succesful, when the program will write what category you choosed.
#  
#   Shortly thereafter (a few sec) a pop-up-window appears (possibly "behind" the 
#   RStudio frame,  use alt-tab), where you chose the raw csv-file in 
#   the usual windows manner. 
#  
#   While R-studio is working, the ">"-sign on the bottom-row of the bottom-left
#   line (the command line) will not be visible.  
#
#   Program disposition (for adding new code and/or maintenance purposes)
#   The program is written in a one-long-file-disposition to facilitate for the
#   end user. The disposition is as follows:
#     
#   - Check for and load packages  
#   - Define facilitating functions which will be used further down the program.
#      (reName, as.numeric.factor)
#   - Load the E-prime output-file into R
#   - Remove unneccesary and unwanted columns and data. This part is a little messy,
#      due to late changes in the specification.
#   - Code the triplets 
#   - Perform data management, using the reshape-packages functions melt and cast
#     (this part of the code is in blocks named "data 1","data 2" and so on, 
#        with descriptive headers)
#   - Print the result to a csv-file. 
#     
#     Sidenote
#     In as.numeric.factor, warnings: "NAs introduced by coercion" are supressed,
#     since no NA:s are written. NA:s in the processed csv-file is a result of 
#     no instances  of repetitions or triplets in the subsetted data.
#
#     The prompts and print/output messages are written in swedish.
#     The program was written the summer 2014 using RStudio with
#     R version 3.0.3 (2014-03-06) -- "Warm Puppy" by Oskar Gauffin

db<-function(){
  
  # Save starting time
  ptm<-proc.time()
  
  #If required install and load packages "reshape" och "gtools" 
  if(sum(installed.packages()[,1]=="reshape")==0){
    install.packages("reshape")
  }
  if(sum(installed.packages()[,1]=="gtools")==0){
    install.packages("gtools")      
  }
  require(reshape)
  require(gtools)
  
  
  # Ask for what categories to run the programme over
  blockTypeEpok=F
  blockTypeAll=F
  blocktype=NA
  while (is.na(blocktype[1])){ 
    arg<-ask("Ange vilken blockenhet som ska användas('Halvblock','Block', 'Epok','Alla')")
    print(paste("Du har valt",arg))
    
    if (arg=="Alla"){
      blocktype=c("HalvBlock","Block","Epok")
      blockname=c("HB","B","E")
      blockTypeAll=T
    } else if (arg=="Epok"){
      blocktype=c("Block", "Epok")
      blockname=c("B","E")
      blockTypeEpok=T
    } else if (arg=="Block"){
      blocktype="Block"
      blockname="B"
    } else if (arg=="Halvblock"){
      blocktype="HalvBlock"
      blockname="HB"
    } else print("Kände inte igen blockenheten. Försök igen")
  }
  
  #FUNCTIONS-------------------------------------------------
  
  # Funktion reName
  # Splits a string by X, removes X, splits on "." and puts it back together in 
  # desired order.
  reName<-function(string)                 
  {
    #Split at X
    res<-rep("tom",length(string))
    splitted<-strsplit(string,"X")
    for (i in 1:length(string)){
      res[i]<-splitted[[i]][2]
    }
    
    #Split at "."
    splitted2<-strsplit(res, split = "\\.")
    splitted2
    for (i in 1:length(string)){
      if (splitted2[[i]][2]=="firstRT"){
        splitted2[[i]][2]="fsRT"
      } else if (splitted2[[i]][2]=="finalRT"){
        splitted2[[i]][2]="flRT"
      } else if (splitted2[[i]][2]=="firstACC"){
        splitted2[[i]][2]="Acc"
      }
      res[i]<-paste(splitted2[[i]][2],splitted2[[i]][1],sep="_")
    }
    
    res    
  }
  
  # Function for converting factor to numeric
  # Takes a factor and returns numeric. Generates warnings if
  # not supressed.
  as.numeric.factor<-function(x){
    (as.numeric(levels(x))[x])
  }
    
  ## Data-management----------------------------------
  
  # Read the raw csv-file
  alldata<-read.csv(file.choose(),dec=",",header=T,sep=";")
  
  # Remove some columns
  data<-subset(alldata,select=c(2,3,14,19,24,25,43:48,51,55,60))
  
  #Fix column names
  cnames<-as.character(data[1,1])
  for (i in 2:ncol(data)){
    cnames<-c(cnames,as.character(data[1,i]))
  }
  colnames(data)<-cnames
  data<-data[-1,]
  
  #Remove practice rows, by choosing rows where InstructionList is empty
  data<-data[(""==data$InstructionList),]
  
  # Convert factor to numeric
  index <- c(1, 2, 3, 5:12)
  suppressWarnings(
    for (i in 2:length(index)) {
      data[, index[i]] <- as.numeric.factor(data[, index[i]])
    }
  )
  
  # Code the triplets
  RepMat <- cbind(rep(1, 3), rep(2, 3), rep(3, 3), rep(4, 3))
  
  TrilMat <- cbind(c(1, 2, 1), c(1, 3, 1), c(1, 4, 1), c(2, 1, 2), c(2, 3, 2), 
                   +c(2, 4, 2), c(3, 1, 3), c(3, 2, 3), c(3, 4, 3), c(4, 1, 4), 
                   +c(4, 2, 4), c(4, 3, 4))
  
  HfMat <- cbind(c(1, 1, 2), c(1, 2, 2), c(1, 3, 2), c(1, 4, 2), c(2, 1, 4), 
                 +c(2, 2, 4), c(2, 3, 4), c(2, 4, 4), +c(4, 1, 3), c(4, 2, 3), c(4, 3, 3), 
                 +c(4, 4, 3), c(3, 1, 1), c(3, 2, 1), c(3, 3, 1), c(3, 4, 1))
  
  TypeMat <- cbind(RepMat, TrilMat, HfMat)
  TypeMat <- rbind(TypeMat, 1:ncol(TypeMat))
  TripType <- rep(0, nrow(data))
  
  for (i in 3:nrow(data)) {
    triplett <- data$event[(i - 2):i]
    
    aktTripType <- "L"
    for (j in 1:ncol(TypeMat)) if (triplett[1] == TypeMat[1, j] && triplett[2] == 
                                     TypeMat[2, j] && triplett[3] == TypeMat[3, j]) {
      if ((0 < TypeMat[4, j]) && (TypeMat[4, j] < 5)) 
        aktTripType <- "R" else if ((4 < TypeMat[4, j]) && TypeMat[4, j] < 17) 
          aktTripType <- "T" else aktTripType = "H"
    }
    TripType[i] <- aktTripType
  }
  
  data <- cbind(data, TripType)
  
  # Remove more practice rows, can be done now since the triplets are coded
  data <- data[("" == data$PracTrialList.Cycle), ]
  
  # Remove InstructionList,LearnTrialList och PracTrialList.Cycle
  data <- data[, c(-4, -13, -14)]
  
  # Adjust blockindex
  data$Block <- data$Block - 8
  
  # Since the two first rows in every block is not a real triplet, we put
  # these as NA:s.
  
  # To be able to do this, we convert some factors to character 
  data$TrialType <- as.character(data$TrialType)
  data$TripType <- as.character(data$TripType)
  
  navector<-c(cumsum(c(1,rep(80,nrow(data)/80-1))),cumsum(c(2,rep(80,nrow(data)/80-1))))
  data[navector,ncol(data)]=NA
  
  data <- data[, c(1, 2, 3, 4, 6, 5, 12, 13, 7, 8, 9, 10, 11)]
  
  # Late change in specification: the NA-rows are to be removed.
  data<-data[!is.na(data$TripType),]
  
  #Remove column Correct Response (Could be done above, to clean things up)
  data<-data[,c(-6)]
  
  # Add 20 on blockindex, if nr of blocks on first day should be altered, 20 must be 
  # changed to some find the max-expression.
  data[(data$Session==2),3]<-data[(data$Session==2),3]+20
  
  # Preparations for creating columns with halfblock and epoch index.
  # number of participants      nSub
  # number of blocks            nBlock
  # length of blocks            lengthBlock
  # participants ID             SubID
  mdata<-melt(data, id.vars=names(data)[c(1,3)], measure.vars="firstRT")
  M<-data.frame(cast(mdata,Subject~Block~variable, median))
  nSub<-nrow(M)
  nBlock=max(data$Block)
  lengthBlock<-(max(data$Trial)-min(data$Trial)+1)
  SubID<-as.numeric(rownames(M))
  
  #Add the halfblocksindex-column 
  nHalvBlock<-nBlock*2
  lengthHalvBlock<-lengthBlock/2
  halvBlock<-rep(1,lengthHalvBlock)
  
  for (i in 2:nHalvBlock){
    halvBlock<-cbind((halvBlock),rep(i, lengthHalvBlock))
  }
  HalvBlock<-rep(halvBlock,nSub)
  data<-cbind(data,HalvBlock)
  
  # Add the epochindex-column
  nEpok<-nBlock/5
  lengthEpok<-lengthBlock*5
  epok<-rep(1,lengthEpok)
  
  for (i in 2:nEpok){
    epok<-cbind(epok,rep(i, lengthEpok))
  }
  Epok<-rep(epok,nSub)
  data<-cbind(data,Epok)
  
  
  # Build the output file (resb)
  resb<-SubID
  
  bnames=NA
  blockData=NA
  epokData=NA
  
  for (b in 1:length(blocktype)){
    # To be able to evaluate the string blocktype b, create string variable cvar
    cvar<-paste("Subject",blocktype[b],"variable",sep="~")
    
    # Data 1  (fsRT,flRT, Acc with Pattern/Random/All) ---------------
    
    # Data1 : Pattern
    dataP<-data[data$TrialType=="P",]
    
    #FinalRT
    mdata<-melt(dataP, id=c("Subject", blocktype[b]), meas="finalRT")
    finalRT_P<-data.frame(cast(mdata, cvar, median))
    names(finalRT_P)<-reName(names(finalRT_P))
    names(finalRT_P)<-paste0("P_All_",names(finalRT_P))
    
    #FirstRT
    mdata<-melt(dataP, id=c("Subject", blocktype[b]), meas="firstRT")
    firstRT_P<-data.frame(cast(mdata, cvar, median))
    names(firstRT_P)<-reName(names(firstRT_P))
    names(firstRT_P)<-paste0("P_All_",names(firstRT_P))
    
    #Acc
    mdata<-melt(dataP, id.vars=c("Subject",blocktype[b]),meas="firstACC")
    Acc_P<-data.frame(cast(mdata,cvar,mean))
    names(Acc_P)<-reName(names(Acc_P))
    names(Acc_P)<-paste0("P_All_",names(Acc_P))
    
    # Data1 : Random
    dataR<-data[data$TrialType=="R",]
    
    #FinalRT
    mdata<-melt(dataR, id=c("Subject", blocktype[b]), meas="finalRT")
    finalRT_R<-data.frame(cast(mdata, cvar, median))
    names(finalRT_R)<-reName(names(finalRT_R))
    names(finalRT_R)<-paste0("R_All_",names(finalRT_R))
    
    #FirstRT
    mdata<-melt(dataR, id=c("Subject", blocktype[b]), meas="firstRT")
    firstRT_R<-data.frame(cast(mdata, cvar, median))
    names(firstRT_R)<-reName(names(firstRT_R))
    names(firstRT_R)<-paste0("R_All_",names(firstRT_R))
    
    #Acc
    mdata<-melt(dataR, id.vars=c("Subject",blocktype[b]),meas="firstACC")
    Acc_R<-data.frame(cast(mdata,cvar,mean))
    names(Acc_R)<-reName(names(Acc_R))
    names(Acc_R)<-paste0("R_All_",names(Acc_R))
    
    # Merge
    data1_PoR<-cbind(finalRT_P,finalRT_R,firstRT_P,firstRT_R,Acc_P,Acc_R)
    
    # Data 1 : Total (fsRT, Acc)
    
    #firstRT_Tot
    mdata<-melt(data, id=c("Subject", blocktype[b]), meas="firstRT")
    firstRT_Tot<-data.frame(cast(mdata, cvar, median))
    names(firstRT_Tot)<-reName(names(firstRT_Tot))
    names(firstRT_Tot)<-paste0("Tot_All_",names(firstRT_Tot))
    
    #Acc_Tot
    mdata<-melt(data, id.vars=c("Subject",blocktype[b]),meas="firstACC")
    Acc_Tot<-data.frame(cast(mdata,cvar,mean))
    names(Acc_Tot)<-reName(names(Acc_Tot))
    names(Acc_Tot)<-paste0("Tot_All_",names(Acc_Tot))
    
    # Data 1: Diffar
    RT_RPDiff<-cbind(finalRT_R,firstRT_R)-cbind(finalRT_P,firstRT_P)
    splitted<-strsplit(names(RT_RPDiff),"R_")
    for (i in 1:length(names(RT_RPDiff))){
      names(RT_RPDiff)[i]<-splitted[[i]][2]}
    names(RT_RPDiff)<-paste0("RPDiff_",names(RT_RPDiff))  
    
    Acc_RPDiff<-Acc_P-Acc_R
    splitted<-strsplit(names(Acc_RPDiff),"P_")
    for (i in 1:length(names(Acc_RPDiff))){
      names(Acc_RPDiff)[i]<-splitted[[i]][2]}
    names(Acc_RPDiff)<-paste0("RPDiff_",names(Acc_RPDiff))
    
    # Merge the whole data1
    res<-cbind(data1_PoR,firstRT_Tot,Acc_Tot,RT_RPDiff,Acc_RPDiff)
    
    #Data 2 (Same as data 1, but just with HF och LF, i.e. no trills or reps)--------
    HLdata <- data[data$TripType == "H" | data$TripType =="L",]
    
    # Data2 : Pattern
    dataP<-HLdata[HLdata$TrialType=="P",]
    
    #FinalRT
    mdata<-melt(dataP, id=c("Subject", blocktype[b]), meas="finalRT")
    finalRT_P<-data.frame(cast(mdata, cvar, median))
    names(finalRT_P)<-reName(names(finalRT_P))
    names(finalRT_P)<-paste0("P_Red_",names(finalRT_P))
    
    #FirstRT
    mdata<-melt(dataP, id=c("Subject", blocktype[b]), meas="firstRT")
    firstRT_P<-data.frame(cast(mdata, cvar, median))
    names(firstRT_P)<-reName(names(firstRT_P))
    names(firstRT_P)<-paste0("P_Red_",names(firstRT_P))
    
    #Acc
    mdata<-melt(dataP, id.vars=c("Subject",blocktype[b]),meas="firstACC")
    Acc_P<-data.frame(cast(mdata,cvar,mean))
    names(Acc_P)<-reName(names(Acc_P))
    names(Acc_P)<-paste0("P_Red_",names(Acc_P))
    
    # Data2 : Random
    dataR<-HLdata[HLdata$TrialType=="R",]
    
    #FinalRT
    mdata<-melt(dataR, id=c("Subject", blocktype[b]), meas="finalRT")
    finalRT_R<-data.frame(cast(mdata, cvar, median))
    names(finalRT_R)<-reName(names(finalRT_R))
    names(finalRT_R)<-paste0("R_Red_",names(finalRT_R))
    
    #FirstRT
    mdata<-melt(dataR, id=c("Subject", blocktype[b]), meas="firstRT")
    firstRT_R<-data.frame(cast(mdata, cvar, median))
    names(firstRT_R)<-reName(names(firstRT_R))
    names(firstRT_R)<-paste0("R_Red_",names(firstRT_R))
    
    #Acc
    mdata<-melt(dataR, id.vars=c("Subject",blocktype[b]),meas="firstACC")
    Acc_R<-data.frame(cast(mdata,cvar,mean))
    names(Acc_R)<-reName(names(Acc_R))
    names(Acc_R)<-paste0("R_Red_",names(Acc_R))
    
    # Merge
    data2_PoR<-cbind(finalRT_P,finalRT_R,firstRT_P,firstRT_R,Acc_P,Acc_R)
    
    # Data 2 : Totala (fsRT, Acc)
    
    #firstRT
    mdata<-melt(HLdata, id=c("Subject", blocktype[b]), meas="firstRT")
    firstRT_Tot<-data.frame(cast(mdata, cvar, median))
    names(firstRT_Tot)<-reName(names(firstRT_Tot))
    names(firstRT_Tot)<-paste0("Tot_Red_",names(firstRT_Tot))
    
    #firstACC
    mdata<-melt(HLdata, id.vars=c("Subject",blocktype[b]),meas="firstACC")
    Acc_Tot<-data.frame(cast(mdata,cvar,mean))
    names(Acc_Tot)<-reName(names(Acc_Tot))
    names(Acc_Tot)<-paste0("Tot_Red_",names(Acc_Tot))
    
    # Data 2: Diffar
    RT_RPDiff<-cbind(finalRT_R,firstRT_R)-cbind(finalRT_P,firstRT_P)
    splitted<-strsplit(names(RT_RPDiff),"R_")
    for (i in 1:length(names(RT_RPDiff))){
      names(RT_RPDiff)[i]<-splitted[[i]][2]}
    names(RT_RPDiff)<-paste0("RPDiff_",names(RT_RPDiff))  
    
    Acc_RPDiff<-Acc_P-Acc_R
    splitted<-strsplit(names(Acc_RPDiff),"P_")
    for (i in 1:length(names(Acc_RPDiff))){
      names(Acc_RPDiff)[i]<-splitted[[i]][2]}
    names(Acc_RPDiff)<-paste0("RPDiff_",names(Acc_RPDiff))
    
    # Merge the whole data2
    res<-cbind(res,data2_PoR,firstRT_Tot,Acc_Tot,RT_RPDiff,Acc_RPDiff)  
    
    # Data3 (flRT,fsRT,Acc by High/Low/Rep/Tril) --------------------------------------------
    
    ## Data3 : High/Low 
    dataTTH<-data[data$TripType=="H",]
    dataTTL<-data[data$TripType=="L",]
    
    #finalRT High
    mdata<-melt(dataTTH, id.vars=c("Subject",blocktype[b]), meas="finalRT")
    finalRT_H<-data.frame(cast(mdata,cvar, median))
    names(finalRT_H)<-reName(names(finalRT_H))
    names(finalRT_H)<-paste0("High_",names(finalRT_H))
    
    #finalRT Low
    mdata<-melt(dataTTL, id.vars=c("Subject",blocktype[b]), meas="finalRT")
    finalRT_L<-data.frame(cast(mdata,cvar, median))
    names(finalRT_L)<-reName(names(finalRT_L))
    names(finalRT_L)<-paste0("Low_",names(finalRT_L))
    
    #firstRT High
    mdata<-melt(dataTTH, id.vars=c("Subject",blocktype[b]), meas="firstRT")
    firstRT_H<-data.frame(cast(mdata,cvar, median))
    names(firstRT_H)<-reName(names(firstRT_H))
    names(firstRT_H)<-paste0("High_",names(firstRT_H))
    
    #firstRT Low
    mdata<-melt(dataTTL, id.vars=c("Subject",blocktype[b]), meas="firstRT")
    firstRT_L<-data.frame(cast(mdata,cvar, median))
    names(firstRT_L)<-reName(names(firstRT_L))
    names(firstRT_L)<-paste0("Low_",names(firstRT_L))
    
    #Acc High
    mdata<-melt(dataTTH, id.vars=c("Subject",blocktype[b]),meas="firstACC")
    Acc_H<-data.frame(cast(mdata,cvar,mean))
    names(Acc_H)<-reName(names(Acc_H))
    names(Acc_H)<-paste0("High_",names(Acc_H))
    
    #Acc Low
    mdata<-melt(dataTTL, id.vars=c("Subject",blocktype[b]),meas="firstACC")
    Acc_L<-data.frame(cast(mdata,cvar,mean))
    names(Acc_L)<-reName(names(Acc_L))
    names(Acc_L)<-paste0("Low_",names(Acc_L))
    
    data3_HoL<-cbind(finalRT_H,finalRT_L,firstRT_H,firstRT_L,Acc_H,Acc_L)
    
    ##Data 3 : Reps/Trills 
    dataTTR<-data[data$TripType=="R",]
    dataTTT<-data[data$TripType=="T",]
    
    #finalRT Reps
    mdata<-melt(dataTTR, id.vars=c("Subject",blocktype[b]), meas="finalRT")
    finalRT_Rep<-data.frame(cast(mdata,cvar, median))
    names(finalRT_Rep)<-reName(names(finalRT_Rep))
    names(finalRT_Rep)<-paste0("Reps_",names(finalRT_Rep))
    
    #firstRT Reps
    mdata<-melt(dataTTR, id.vars=c("Subject",blocktype[b]), meas="firstRT")
    firstRT_Rep<-data.frame(cast(mdata,cvar, median))
    names(firstRT_Rep)<-reName(names(firstRT_Rep))
    names(firstRT_Rep)<-paste0("Reps_",names(firstRT_Rep))
    
    #Acc Reps
    mdata<-melt(dataTTR, id.vars=c("Subject",blocktype[b]),meas="firstACC")
    Acc_Rep<-data.frame(cast(mdata,cvar,mean))    
    names(Acc_Rep)<-reName(names(Acc_Rep))
    names(Acc_Rep)<-paste0("Reps_",names(Acc_Rep))
    
    #finalRT Trils
    mdata<-melt(dataTTT, id.vars=c("Subject",blocktype[b]), meas="finalRT")
    finalRT_Tril<-data.frame(cast(mdata,cvar, median))
    names(finalRT_Tril)<-reName(names(finalRT_Tril))
    names(finalRT_Tril)<-paste0("Trils_",names(finalRT_Tril))
    
    #firstRT Trils
    mdata<-melt(dataTTT, id.vars=c("Subject",blocktype[b]), meas="firstRT")
    firstRT_Tril<-data.frame(cast(mdata,cvar, median))
    names(firstRT_Tril)<-reName(names(firstRT_Tril))
    names(firstRT_Tril)<-paste0("Trils_",names(firstRT_Tril))
    
    #Acc Trils
    mdata<-melt(dataTTT, id.vars=c("Subject",blocktype[b]),meas="firstACC")
    Acc_Tril<-data.frame(cast(mdata,cvar,mean))
    names(Acc_Tril)<-reName(names(Acc_Tril))
    names(Acc_Tril)<-paste0("Trils",names(Acc_Tril))
    
    data3_RoT<-cbind(finalRT_Rep,firstRT_Rep,Acc_Rep,finalRT_Tril,firstRT_Tril,Acc_Tril)
    
    ##Diff
    RT_HLDiff<-cbind(finalRT_L,firstRT_L)-cbind(finalRT_H,firstRT_H)
    splitted<-strsplit(names(RT_HLDiff),"Low_")
    for (i in 1:length(names(RT_HLDiff))){
      names(RT_HLDiff)[i]<-splitted[[i]][2]}
    names(RT_HLDiff)<-paste0("LHDiff_",names(RT_HLDiff))
    
    Acc_HLDiff<-Acc_H-Acc_L
    splitted<-strsplit(names(Acc_HLDiff),"High_")
    for (i in 1:length(names(Acc_HLDiff))){
      names(Acc_HLDiff)[i]<-splitted[[i]][2]}
    names(Acc_HLDiff)<-paste0("LHDiff_",names(Acc_HLDiff))
    
    # Merge
    res<-cbind(res,data3_HoL,data3_RoT,RT_HLDiff, Acc_HLDiff)
    names(res)<-paste0(blockname[b],"_",names(res))
    
    if (blocktype[b]=="Block"){
      blockData<-res
    }
    
    # If run by epoch, data will be built using the programme run by block, further
    # down the programme.
    if (blocktype[b]=="Epok"){
      bnames<-names(res)
      epokData<-res
    }
    else
      resb<-cbind(resb,res)
  }
  
  #   If run by epoch, take the mean of each five blocks, for
  #   first_RT, finalRT and Acc.
  
  if (blockTypeEpok==T|blockTypeAll==T){
    E_df<-data.frame(matrix(0,nrow=length(SubID),ncol=ncol(blockData)/5))
    for (c in 1:(ncol(blockData)/5)){
      splitname<-strsplit(names(blockData[1+5*(c-1)]),"B_")
      names(E_df)[c]<-paste0("E_",splitname[[1]][2])
      
      for (p in 1:length(SubID)){
        E_df[p,c]<-apply(blockData[p,(1+(c-1)*5):(c*5)],1, mean)
        
      }
      
      
      # #       Om vi vill beräkna epoker enbart med de block som inte är NA: Byt in denna i for-loopen ovan.
      #         E_df[p,c]<-apply(blockData[p,(1+(c-1)*5):(c*5)][,!is.na(blockData[p,(1+(c-1)*5):(c*5)])],1,mean) 
      
    } 
    
    # Take names from resb
    names(E_df)<-bnames
    
    if(blockTypeEpok==T){
      resb<-cbind(SubID,E_df)
    }
    if (blockTypeAll==T){
      resb<-cbind(resb,E_df)
    } 
  }
  
  # Write correct names, and sort in descending participant index 
  names(resb)[1]<-"Subject"
  resb<-resb[order(resb[,1]),]
  
  # Write the csv-file and info to user
  write.table(resb, "processed.csv", dec=",", row.names=F,col.names=names(resb))
  print(paste("Utdatan består av",dim(resb)[1],"deltagare, och ",dim(resb)[2],"kolumner."))
  print(paste("Den färdiga datafilen är sparad i ",getwd(), " och heter processed.csv"))
  
  print("Körningens tidsdata: ")
  print(proc.time()[3]-ptm[3])
  resb
}
